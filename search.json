[
  {
    "objectID": "Untitled2.html",
    "href": "Untitled2.html",
    "title": "ChewC",
    "section": "",
    "text": "# import torch\n# import matplotlib.pyplot as plt\n# from matplotlib.animation import FuncAnimation\n\n# # Parameters\n# pop_size = 200\n# h2 = 0.3\n# reps = 5\n# num_generations = 50\n\n# # Assume the Genome, create_pop, create_random_pop, Trait, run_generation functions are defined elsewhere\n# # Initialize genome and founder population\n# G = Genome(1, 1000)\n# P = create_pop(G, create_random_pop(G, pop_size))\n# T = Trait(G, P, 0, 1)\n\n# # Store populations for plotting\n# pops = [P]\n\n# # Run multiple generations\n# for generation in range(num_generations):\n#     P = run_generation(P, T, h2, reps, pop_size, selection_fraction=1/reps)\n#     pops.append(P)\n\n# # Determine the max and min phenotype values for setting consistent axes\n# all_phenotypes = torch.cat([pop.phenotypes for pop in pops])\n# max_val = torch.max(all_phenotypes).item()\n# min_val = torch.min(all_phenotypes).item()\n\n# # Create the figure and axis\n# fig, ax = plt.subplots()\n\n# def update(frame):\n#     ax.clear()\n#     ax.hist(pops[frame].phenotypes.numpy(), alpha=0.3, bins=20, range=(min_val, max_val))\n#     ax.set_title(f'Generation {frame}')\n#     ax.set_xlim(min_val, max_val + (max_val*.1))\n#     ax.set_ylim(0, pop_size // 2)  # Adjust the y-axis limit as needed\n#     ax.set_xlabel('Phenotype')\n#     ax.set_ylabel('Frequency')\n\n# # Create the animation\n# ani = FuncAnimation(fig, update, frames=num_generations + 1, repeat=False)\n\n# # Display the animation in the notebook\n# from IPython.display import HTML\n# HTML(ani.to_jshtml())\n\n# # Save the animation as a GIF\n# ani.save('phenotype_animation.gif', writer='pillow')\n\n# # Display the animation in the notebook (optional)\n# from IPython.display import Image\n# Image(filename='phenotype_animation.gif')",
    "crumbs": [
      "Untitled2.html"
    ]
  },
  {
    "objectID": "x01_populationStatistics.html",
    "href": "x01_populationStatistics.html",
    "title": "ChewC",
    "section": "",
    "text": "#x01_populationStatistics\n\n\n\nimport matplotlib.pyplot as plt\nfrom fastcore.basics import patch\nimport uuid\nimport pdb\nimport torch\nfrom matplotlib.animation import FuncAnimation\nimport torch\nimport torch.optim as optim\nimport torch.nn.functional as F\nimport torch.nn as nn\nimport gymnasium as gym\nimport numpy as np\ndevice='cpu'\n\nclass Genome:\n    def __init__(self, n_chr, n_loci):\n        self.ploidy = 2\n        self.n_chr = n_chr\n        self.n_loci = n_loci\n        self.shape = (self.ploidy, self.n_chr, self.n_loci)\n        \nclass Population:\n    def __init__(self, genome, haplotypes, device=device):\n        self.genome = genome\n        self.device = device\n        self.phenotypes = None\n        self.bvs = None\n        self.haplotypes = haplotypes\n        self.dosages = haplotypes.sum(dim=1).float()\n        self.size = haplotypes.shape[0]\n                \nclass Trait:\n    def __init__(self, genome, founder_population, target_mean, target_variance, device=device):\n        self.target_mean = target_mean\n        self.target_variance = target_variance\n        self.device = device\n        random_effects = torch.randn(genome.n_chr, genome.n_loci, device=self.device)\n        random_effects -= random_effects.mean()\n        founder_scores = torch.einsum('kl,hkl-&gt;h', random_effects, founder_population.dosages)\n        founder_mean, founder_var = founder_scores.mean(), founder_scores.var()\n        scaling_factors = torch.sqrt(self.target_variance / founder_var)\n        self.scaling_factors = scaling_factors\n        random_effects *= scaling_factors\n        self.effects = random_effects\n        self.intercept = founder_mean - target_mean\n\n        \ndef calculate_breeding_value(population_dosages, trait_effects, device = device):\n    return torch.einsum('hjk,jk-&gt;h', population_dosages,trait_effects)\n\ndef truncation_selection(population, trait, top_percent):\n    return torch.topk(population.phenotypes, top_percent).indices\n\n# meiosis\ndef recombine(parent_haplo_tensor, recombination_rate=0.1):\n    num_individuals, ploidy, num_chromosomes, num_loci = parent_haplo_tensor.shape    \n    # Generate crossover masks\n    maternal, paternal = parent_haplo_tensor[:,0,:,:],parent_haplo_tensor[:,1,:,:],\n    crossovers = torch.bernoulli(torch.full((num_individuals, num_chromosomes, num_loci), recombination_rate, device=device))\n    #crossovers = torch.rand((num_individuals, num_chromosomes, num_loci), device=device) &lt; recombination_rate\n    progeny = maternal * (1 - crossovers) + paternal * crossovers\n    return progeny\n\n\ndef phenotype(population, trait, h2):\n    breeding_values = calculate_breeding_value(population.dosages, trait.effects) \n    \n    if breeding_values.var() == 0:\n#         print('phenotype: no var')\n        environmental_variance = 0  \n    else:\n        environmental_variance = (1 - h2) / h2 * breeding_values.var() \n    \n    # Check if environmental_variance is zero before applying torch.sqrt and .clone()\n    if environmental_variance == 0:\n        environmental_noise = torch.zeros(breeding_values.shape, device=device)\n    else:\n        environmental_noise = torch.randn(breeding_values.shape, device=device) * torch.sqrt(environmental_variance).detach()\n    \n    population.breeding_values = breeding_values\n    population.phenotypes = breeding_values + environmental_noise\n#     def _create_random_haplotypes(self,num_individuals):\n#         return torch.randint(0, 2, (num_individuals, *self.g.shape), device=self.device)\ndef create_random_pop(G, pop_size):\n    return torch.randint(0, 2, (pop_size, *G.shape), device= device)\n\ndef update_pop(population, haplotype_pop_tensor):\n    population.haplotypes = haplotype_pop_tensor\n    population.dosages = haplotype_pop_tensor.sum(dim=1).float()\n    return population\n\n# meiosis\ndef recombine(parent_haplo_tensor, recombination_rate=0.1):\n    num_individuals, ploidy, num_chromosomes, num_loci = parent_haplo_tensor.shape\n    # Generate crossover masks\n    maternal, paternal = parent_haplo_tensor[:,0,:,:],parent_haplo_tensor[:,1,:,:],\n    crossovers = torch.bernoulli(torch.full((num_individuals, num_chromosomes, num_loci), recombination_rate, device=device))\n#     crossovers = torch.rand((num_individuals, num_chromosomes, num_loci), device=device) &lt; recombination_rate\n    progeny = maternal * torch.logical_not(crossovers) + paternal * crossovers\n    return progeny\n\ndef breed(mother_tensor, father_tensor, recombination_rate=0.1):\n    eggs = recombine(mother_tensor,recombination_rate)\n    pollens = recombine(father_tensor,recombination_rate)\n    return torch.stack((eggs,pollens), dim=1)\n\ndef create_pop(G, haplotypes):\n    return Population(G, haplotypes=haplotypes)\n\ndef bv(P,T):\n    P.breeding_values = calculate_breeding_value(P.dosages,T.effects)\n    \ndef create_progeny(mother_gametes, father_gametes,reps = 1):\n    progeny = []\n    for _ in range(reps):\n        # Randomly shuffle the gametes from each parent \n        shuffled_mother_indices = torch.randperm(mother_gametes.shape[0])\n        shuffled_father_indices = torch.randperm(father_gametes.shape[0])\n\n        # Select the shuffled gametes\n        mother_gametes = mother_gametes[shuffled_mother_indices]\n        father_gametes = father_gametes[shuffled_father_indices]\n\n        # Stack the gametes to create progeny haplotypes\n        progeny_haplotypes = torch.stack((mother_gametes, father_gametes),dim=1)\n        progeny.append(progeny_haplotypes)\n    return torch.vstack(progeny)\n\n\n\n\nclass BreedingEnvironment(gym.Env):\n    def __init__(self, G, T, h2, reps, pop_size, max_generations=10):\n        super(BreedingEnvironment, self).__init__()\n        \n        self.G = G\n        self.T = T\n        self.h2 = h2\n        self.reps = reps\n        self.pop_size = pop_size\n        self.max_generations = max_generations\n        \n        # Define action and observation space\n        self.action_space = spaces.Box(low=0, high=1, shape=(pop_size,), dtype=np.float32)\n        obs_dim = G.n_chr * G.n_loci * 2 * pop_size + 1  # Flattened population genotype + generation progress\n        self.observation_space = spaces.Box(low=0, high=1, shape=(obs_dim,), dtype=np.float32)\n        \n        self.reset()\n    \n    def step(self, action):\n        # Select parents based on action\n        selected_parent_indices = self.select_parents(action)\n        selected = self.population.haplotypes[selected_parent_indices]\n        \n        # Breeding\n        m = recombine(selected)  # Mother gametes\n        f = recombine(selected)  # Father gametes\n        progeny = create_progeny(m, f, reps=self.reps)\n        \n        # Create new population from progeny\n        self.population = create_pop(self.G, progeny)\n        phenotype(self.population, self.T, self.h2)\n        \n        # Calculate reward (e.g., improvement in mean phenotype)\n        reward = self.calculate_reward()\n        \n        # Update generation counter\n        self.current_generation += 1\n        \n        # Check if episode is done\n        done = self.current_generation &gt;= self.max_generations\n        \n        # Get new state\n        obs = self.get_observation()\n        \n        return obs, reward, done, {}\n    \n    def reset(self):\n        # Create initial population\n        initial_haplotypes = create_random_pop(self.G, self.pop_size)\n        self.population = create_pop(self.G, initial_haplotypes)\n        phenotype(self.population, self.T, self.h2)\n        self.current_generation = 0\n        \n        return self.get_observation()\n    \n    def get_observation(self):\n        # Flatten population genotype and add generation progress\n        flattened_genotype = self.population.haplotypes.view(-1).numpy()\n        generation_progress = np.array([self.current_generation / self.max_generations])\n        return np.concatenate([flattened_genotype, generation_progress])\n    \n    def select_parents(self, action):\n        # Select top 10% as parents based on the action\n        k = int(self.pop_size * 0.1)\n        return np.argsort(action)[-k:]\n    \n    def calculate_reward(self):\n        # For example, use the improvement in mean phenotype as reward\n        return self.population.phenotypes.mean().item()\n    \n\nn_chr = 1\nn_loci = 500\nfounder_pop_size = 200\n\nG = Genome(n_chr, n_loci)\nfounder_pop = create_pop(G, create_random_pop(G, founder_pop_size))\nT = Trait(G, founder_pop, target_mean=0.0, target_variance=1.0)\n\n\nfrom stable_baselines3 import PPO\nfrom gymnasium.spaces import Box\nimport gymnasium.spaces as spaces\n\nenv = BreedingEnvironment(G, T, h2=0.5, reps=1, pop_size=200, max_generations=10)\nmodel = PPO(\"MlpPolicy\", env, verbose=1)\nmodel.learn(total_timesteps=10000)\n\nUsing cpu device\nWrapping the env with a `Monitor` wrapper\nWrapping the env in a DummyVecEnv.\n\n\n\n#\n\n\nfrom stable_baselines3 import PPO\nfrom gymnasium.spaces import Box\n\nenv = BreedingEnvironment(G, T, h2=0.5, reps=1, pop_size=200, max_generations=10)\nmodel = PPO(\"MlpPolicy\", env, verbose=1)\nmodel.learn(total_timesteps=10000)",
    "crumbs": [
      "x01_populationStatistics.html"
    ]
  },
  {
    "objectID": "chewc2.html",
    "href": "chewc2.html",
    "title": "ChewC",
    "section": "",
    "text": "source\n\nrun_generation\n\n run_generation (P, T, h2, reps, pop_size, selection_fraction)\n\n\nsource\n\n\ncreate_progeny\n\n create_progeny (mother_gametes, father_gametes, reps=1)\n\n\nsource\n\n\nbv\n\n bv (P, T)\n\n\nsource\n\n\ncreate_pop\n\n create_pop (G, haplotypes)\n\n\nsource\n\n\nbreed\n\n breed (mother_tensor, father_tensor, recombination_rate=0.1)\n\n\nsource\n\n\nrecombine\n\n recombine (parent_haplo_tensor, recombination_rate=0.1)\n\n\nsource\n\n\nupdate_pop\n\n update_pop (population, haplotype_pop_tensor)\n\n\nsource\n\n\ncreate_random_pop\n\n create_random_pop (G, pop_size)\n\n\nsource\n\n\nphenotype\n\n phenotype (population, trait, h2)\n\n\nsource\n\n\nrecombine\n\n recombine (parent_haplo_tensor, recombination_rate=0.1)\n\n\nsource\n\n\ntruncation_selection\n\n truncation_selection (population, trait, top_percent)\n\n\nsource\n\n\ncalculate_breeding_value\n\n calculate_breeding_value (population_dosages, trait_effects,\n                           device='cpu')\n\n\nsource\n\n\nTrait\n\n Trait (genome, founder_population, target_mean, target_variance,\n        device='cpu')\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nPopulation\n\n Population (genome, haplotypes, device='cpu')\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nGenome\n\n Genome (n_chr, n_loci)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n# Parameters\npop_size = 200\nh2 = 0.99\nreps = 5\nnum_generations = 20\n\n# Initialize genome and founder population\nG = Genome(1, 1000)\nP = create_pop(G, create_random_pop(G, pop_size))\nT = Trait(G, P, 0, 1)\n\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\nclass GeneticFeatureExtractor(nn.Module):\n    def __init__(self, input_size, num_features=64):\n        super(GeneticFeatureExtractor, self).__init__()\n        self.num_features = num_features\n        self.conv1 = nn.Conv1d(in_channels=2, out_channels=64, kernel_size=32, stride=8)\n        self.conv2 = nn.Conv1d(in_channels=64, out_channels=16, kernel_size=8, stride=2)\n        \n        # Calculate the size after convolutions\n        conv1_output_size = (input_size - 32) // 8 + 1\n        conv2_output_size = (conv1_output_size - 8) // 2 + 1\n        self.flattened_size = conv2_output_size * 16\n        \n        self.flatten = nn.Flatten()\n        self.mlp = nn.Linear(self.flattened_size, self.num_features)\n\n    def forward(self, x):\n        x1 = self.conv1(x)\n        x1 = torch.relu(x1)\n        x1 = self.conv2(x1)\n        x1 = torch.relu(x1)\n        x1 = self.flatten(x1)\n        x1 = self.mlp(x1)\n\n        # Permute the channels\n        x2 = x.flip(1)\n        x2 = self.conv1(x2)\n        x2 = torch.relu(x2)\n        x2 = self.conv2(x2)\n        x2 = torch.relu(x2)\n        x2 = self.flatten(x2)\n        x2 = self.mlp(x2)\n\n        # Average the outputs\n        x = (x1 + x2) / 2\n        return x\n\n# Function to create dummy data\ndef create_dummy_data(batch_size, channels, length):\n    return torch.randn(batch_size, channels, length)\n\n# Example usage with different input sizes\ninput_length = 7000  # Change this to any length\npop_size = 1\ndummy_data = create_dummy_data(pop_size, 2, input_length)\n\n# Instantiate the model with flexible input size\nmodel = GeneticFeatureExtractor(input_length)\noutput = model(dummy_data)\n\nprint(output.shape)  # Expected output shape: (10, 64)\n\n# Define a simple training loop for demonstration\ncriterion = nn.MSELoss()\noptimizer = optim.Adam(model.parameters(), lr=0.001)\n\n# Dummy target data for demonstration purposes\ntarget = torch.randn(pop_size, 64)\n\n# Training loop\nnum_epochs = 5\nfor epoch in range(num_epochs):\n    optimizer.zero_grad()\n    output = model(dummy_data)\n    loss = criterion(output, target)\n    loss.backward()\n    optimizer.step()\n    print(f\"Epoch {epoch + 1}/{num_epochs}, Loss: {loss.item()}\")\n\ntorch.Size([1, 64])\nEpoch 1/5, Loss: 1.1888068914413452\nEpoch 2/5, Loss: 0.4471087157726288\nEpoch 3/5, Loss: 0.340411901473999\nEpoch 4/5, Loss: 0.07119196653366089\nEpoch 5/5, Loss: 0.07279734313488007\n\n\n\nsource\n\n\npopulation_statistics\n\n population_statistics (population_tensor)\n\n\n# Parameters\npop_size = 200\nh2 = 0.99\nreps = 5\nnum_generations = 20\n\n# Initialize genome and founder population\nG = Genome(1, 1000)\nP = create_pop(G, create_random_pop(G, pop_size))\nT = Trait(G, P, 0, 1)\n\n# Store populations for plotting\npops = [P]\n\n# Run multiple generations\nfor generation in range(num_generations):\n    P = run_generation(P, T, h2, reps, pop_size, selection_fraction=1/reps)\n    pops.append(P)\n\n# Plot phenotypes for each generation\nfor i, P in enumerate(pops):\n    plt.hist(P.phenotypes, alpha=0.3, label=f'Gen {i}')\n\nplt.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nBreedingSimulation\n\n BreedingSimulation (G, T, h2, reps, pop_size, selection_fraction)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n# --- Example Usage ---\nG = Genome(n_chr=7, n_loci=1000)\nfounder_pop_size = 2\nfounder_pop = create_pop(G, create_random_pop(G, founder_pop_size))\nT = Trait(G, founder_pop, target_mean=0.0, target_variance=1.0)\n\nsim = BreedingSimulation(G, T, h2=0.2, reps=3, pop_size=200, selection_fraction=0.5)\n\n# Simulate 10 generations (replace this with your RL training loop)\nfor generation in range(5):\n    # Placeholder: Generate random actions (you'll use your RL agent's policy here)\n    actions = 20\n    state, reward = sim.step(actions) \n    print(f\"Generation {generation+1}: Avg Phenotype = {state:.2f}, Reward = {reward:.2f}\")\n\nsim.plot_history()\n\nGeneration 1: Avg Phenotype = 2.28, Reward = 2.28\nGeneration 2: Avg Phenotype = 3.86, Reward = 3.86\nGeneration 3: Avg Phenotype = 4.18, Reward = 4.18\nGeneration 4: Avg Phenotype = 5.58, Reward = 5.58\nGeneration 5: Avg Phenotype = 6.56, Reward = 6.56\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nprep\n\n prep (tensor)\n\n\nsource\n\n\ncreate_dummy_data\n\n create_dummy_data (batch_size, channels, length)\n\n\nsource\n\n\nCompleteNetwork\n\n CompleteNetwork (input_size, num_features=64, meta_features=16)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing to nest them in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will have their parameters converted too when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nMetaDataProcessor\n\n MetaDataProcessor (num_features=64, meta_features=16)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing to nest them in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will have their parameters converted too when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nGeneticFeatureExtractor\n\n GeneticFeatureExtractor (input_size, num_features=64)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing to nest them in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will have their parameters converted too when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\n# Example usage \ninput_length = 7000 \npop_size = 1\ndummy_geno_data = create_dummy_data(pop_size, 2, input_length)\n\nnum_meta_features = 5 \n# Create dummy meta data (tensor of floats)\ndummy_meta_data = torch.randn(pop_size, num_meta_features)  \n\n# Create the network\nnetwork = CompleteNetwork(input_length, num_features=64, meta_features=16)\n\n# Pass data through the network\naction_output, value_output = network(dummy_geno_data, dummy_meta_data)\n\nprint(action_output.shape)\nprint(value_output.shape)\n\ntorch.Size([1, 64])\ntorch.Size([1, 64])\n\n\n\n# Example usage with different input sizes\ninput_length = 7000  # Change this to any length\npop_size = 1\ndummy_geno_data = create_dummy_data(pop_size, 2, input_length)\nprint(dummy_geno_data.shape)\n# Instantiate the model with flexible input size\nmodel = GeneticFeatureExtractor(input_length)\noutput = model(dummy_data)\n\nprint(output.shape)  # Expected output shape: (10, 64)\n\n# Define a simple training loop for demonstration\ncriterion = nn.MSELoss()\noptimizer = optim.Adam(model.parameters(), lr=0.001)\n\n# Dummy target data for demonstration purposes\ntarget = torch.randn(pop_size, 64)\n\n# Training loop\nnum_epochs = 5\nfor epoch in range(num_epochs):\n    optimizer.zero_grad()\n    output = model(dummy_data)\n    loss = criterion(output, target)\n    loss.backward()\n    optimizer.step()\n    print(f\"Epoch {epoch + 1}/{num_epochs}, Loss: {loss.item()}\")\n\ntorch.Size([1, 2, 7000])\ntorch.Size([1, 64])\nEpoch 1/5, Loss: 0.7243707180023193\nEpoch 2/5, Loss: 0.251212477684021\nEpoch 3/5, Loss: 0.3177489638328552\nEpoch 4/5, Loss: 0.058963704854249954\nEpoch 5/5, Loss: 0.0671977698802948",
    "crumbs": [
      "chewc2.html"
    ]
  },
  {
    "objectID": "x02_chewc-Copy1.html",
    "href": "x02_chewc-Copy1.html",
    "title": "ChewC",
    "section": "",
    "text": "import torch\nimport matplotlib.pyplot as plt\nfrom fastcore.basics import patch\nimport uuid\n\nimport torch\n\ndevice='cpu'\n\nclass Genome:\n    def __init__(self, n_chr, n_loci):\n        self.ploidy = 2\n        self.n_chr = n_chr\n        self.n_loci = n_loci\n        self.shape = (self.ploidy, self.n_chr, self.n_loci)\n        \nclass Population:\n    def __init__(self, genome, haplotypes, device=device):\n        self.genome = genome\n        self.device = device\n        self.phenotypes = None\n        self.haplotypes = haplotypes\n        self.dosages = haplotypes.sum(dim=1).float()\n        \n        \n        \n        \nclass Trait:\n    def __init__(self, genome, founder_population, target_mean, target_variance,default_h2=.99, device=device):\n        self.target_mean = target_mean\n        self.target_variance = target_variance\n        self.default_h2 = default_h2\n        self.device = device\n        random_effects = torch.randn(genome.n_chr, genome.n_loci, device=self.device)\n        random_effects -= random_effects.mean()\n        founder_scores = torch.einsum('kl,hkl-&gt;h', random_effects, founder_population.dosages)\n        founder_mean, founder_var = founder_scores.mean(), founder_scores.var()\n        scaling_factors = torch.sqrt(self.target_variance / founder_var)\n        self.scaling_factors = scaling_factors\n        random_effects *= scaling_factors\n        self.effects = random_effects\n        self.intercept = founder_mean - target_mean\n\n        \ndef calculate_breeding_value(population_dosages, trait_effects, device = device):\n    return torch.einsum('hjk,jk-&gt;h', population_dosages,trait_effects)\n\ndef truncation_selection(population, trait, top_percent):\n    return torch.topk(population.phenotypes, top_percent).indices\n\n# meiosis\ndef recombine(parent_haplo_tensor, recombination_rate=0.1):\n    num_individuals, ploidy, num_chromosomes, num_loci = parent_haplo_tensor.shape    \n    # Generate crossover masks\n    maternal, paternal = parent_haplo_tensor[:,0,:,:],parent_haplo_tensor[:,1,:,:],\n    crossovers = torch.bernoulli(torch.full((num_individuals, num_chromosomes, num_loci), recombination_rate, device=device))\n    #crossovers = torch.rand((num_individuals, num_chromosomes, num_loci), device=device) &lt; recombination_rate\n    progeny = maternal * (1 - crossovers) + paternal * crossovers\n    return progeny\n\n\ndef phenotype(population, trait, h2):\n    breeding_values = calculate_breeding_value(population.dosages, trait.effects) \n    if breeding_values.var() == 0:\n        environmental_variance = 0  \n    else:\n        environmental_variance = (1 - h2) / h2 * breeding_values.var() \n    environmental_noise = torch.randn(breeding_values.shape, device=device) * torch.sqrt(environmental_variance.clone().detach())\n    population.phenotypes = breeding_values + environmental_noise\n\n#     def _create_random_haplotypes(self,num_individuals):\n#         return torch.randint(0, 2, (num_individuals, *self.g.shape), device=self.device)\ndef create_random_pop(G, pop_size):\n    return torch.randint(0, 2, (pop_size, *G.shape), device= device)\n\ndef update_pop(population, haplotype_pop_tensor):\n    population.haplotypes = haplotype_pop_tensor\n    population.dosages = haplotype_pop_tensor.sum(dim=1).float()\n    return population\n\n# meiosis\ndef recombine(parent_haplo_tensor, recombination_rate=0.1):\n    num_individuals, ploidy, num_chromosomes, num_loci = parent_haplo_tensor.shape\n    # Generate crossover masks\n    maternal, paternal = parent_haplo_tensor[:,0,:,:],parent_haplo_tensor[:,1,:,:],\n    crossovers = torch.bernoulli(torch.full((num_individuals, num_chromosomes, num_loci), recombination_rate, device=device))\n#     crossovers = torch.rand((num_individuals, num_chromosomes, num_loci), device=device) &lt; recombination_rate\n    progeny = maternal * torch.logical_not(crossovers) + paternal * crossovers\n    return progeny\n\ndef breed(mother_tensor, father_tensor, recombination_rate=0.1):\n    eggs = recombine(mother_tensor,recombination_rate)\n    pollens = recombine(father_tensor,recombination_rate)\n    return torch.stack((eggs,pollens), dim=1)\n\ndef create_pop(G, haplotypes):\n    return Population(G, haplotypes=haplotypes)\n\ndef bv(P,T):\n    P.breeding_values = calculate_breeding_value(P.dosages,T.effects)\n    \ndef create_progeny(mother_gametes, father_gametes,reps = 1):\n    progeny = []\n    for _ in range(reps):\n        # Randomly shuffle the gametes from each parent \n        shuffled_mother_indices = torch.randperm(mother_gametes.shape[0])\n        shuffled_father_indices = torch.randperm(father_gametes.shape[0])\n\n        # Select the shuffled gametes\n        mother_gametes = mother_gametes[shuffled_mother_indices]\n        father_gametes = father_gametes[shuffled_father_indices]\n\n        # Stack the gametes to create progeny haplotypes\n        progeny_haplotypes = torch.stack((mother_gametes, father_gametes),dim=1)\n        progeny.append(progeny_haplotypes)\n    return torch.vstack(progeny)\n\nG = Genome(10,1000)\nP = create_pop(G, create_random_pop(G, 500))\nupdate_pop(P, create_random_pop(G,300))\nT = Trait(G,P,0,1)\npops = []\n\n\n\nphenotype(P,T,1)\nbv(P,T)\npops.append(P)\n\n\ntop_parents = 20\nselected_parents = P.haplotypes[torch.topk(P.breeding_values,top_parents).indices];\nm = recombine(selected_parents)\nf = recombine(selected_parents)\n\nf1 = create_pop(G,create_progeny(m, f,reps=10))\nbv(f1,T)\npops.append(f1)\n\n\ntop_parents = 20\nselected_parents = f1.haplotypes[torch.topk(f1.breeding_values,top_parents).indices];\nm = recombine(selected_parents)\nf = recombine(selected_parents)\n\nf2 = create_pop(G,create_progeny(m, f,reps=10))\nbv(f2,T)\npops.append(f2)\n\n\ntop_parents = 20\nselected_parents = f2.haplotypes[torch.topk(f2.breeding_values,top_parents).indices];\nm = recombine(selected_parents)\nf = recombine(selected_parents)\n\nf3 = create_pop(G,create_progeny(m, f,reps=10))\nbv(f3,T)\npops.append(f3)\n\n\ntop_parents = 20\nselected_parents = f3.haplotypes[torch.topk(f3.breeding_values,top_parents).indices];\nm = recombine(selected_parents)\nf = recombine(selected_parents)\n\nf4 = create_pop(G,create_progeny(m, f,reps=10))\nbv(f4,T)\npops.append(f4)\n\n\n[x.breeding_values.mean() for x in pops]\n\n[tensor(-0.0146),\n tensor(2.2529),\n tensor(3.2149),\n tensor(3.9587),\n tensor(4.3368)]",
    "crumbs": [
      "x02_chewc-Copy1.html"
    ]
  },
  {
    "objectID": "Untitled.html",
    "href": "Untitled.html",
    "title": "ChewC",
    "section": "",
    "text": "from chewc.chewc import *\nimport torch",
    "crumbs": [
      "Model"
    ]
  },
  {
    "objectID": "Untitled.html#model",
    "href": "Untitled.html#model",
    "title": "ChewC",
    "section": "Model",
    "text": "Model\n\ninput : agent metrics, mating pool metrics\nPossibly we can use rankings for the given mating pool for each of these metrics. e.g ranking on overall estimated fitness, as well as rank of the inbreeding/relatedness\nShort term reward; producing an offspring that\n\nFor each mate, we could give the inbreeding coefficients… as well as estimated fitness. ##### output probability\nneed to figure out better inputs rather than full genotypes\n\n\n\ncompare algo with individual versus collective rewards\n\nI’ve finished writing a python implementation of AlphaSimR. Now I want to do research into MultiAgent RL. I am no expert! Please review my proposal for research. Give it scores out of 100 and how it can improve for the important features like 1) my comprehension of the breeding topic /// 2) my comprehension of the RL topic /// 3) the practicality of this model learning based on my structure/architecture of the model /training\n\n\n\n\n\n\nPROJECT PROPOSAL :\n\n\nMy plan is to do research into breeding designs for breeding programs. e.g. how do we plan which crosses to make given some information (like a genomic prediction model which can provide estimated breeding values). Or the relationships between individuals (e.g. how related/inbred would the two be?). We want to see if we can use a multi-agent paradigm where each plant can rate a given set of individuals in its mating pool. Our hope is that depending on the given information, the agents will adopt different strategies for choosing their partners. The model will be based around individual agents and a breeding pool of other individuals.\n\n\nThe two inputs to the model will be the Agent Module, and the Breeding Pool Module… each Module will contain features that should be influential on the decision of the agent.\n\n\nThe inputs will include the following\n\n\nThe agent’s own meta data will be its genotype, and relative fitness ranking in the mating pool.\n\n\nThe mating pool will include its genotype, the relative fitness in the mating pool, and the relative inbreeding rank to the agent.\n\n\nNote: perhaps we can even ignore the genotypes for the first models?\n\n\n## Reward\n\n\nI am not sure how to do this. I was thinking it could be the number of descendants in the next generation, or the relative rankings (e.g. points for their offspring having highest fitness ranking, or being the least inbred individual with most unique alleles)\n\n\n\ntraining\nwe will use the model to make predictions for each individual in the mating pool and sample from the probability distribution for its mating… then we will use chewc simulator to generate those individuals, get their estimated breeding values, and their true breeding values… we will calculate the rewards based on the next cycle’s population and immediately update the models weights.\n—-|\nIndividual Plants as agents… or gametic agents",
    "crumbs": [
      "Model"
    ]
  },
  {
    "objectID": "01_core.html",
    "href": "01_core.html",
    "title": "ChewC",
    "section": "",
    "text": "Contains the foundational Data Structures of the breeding program: Genome, Individual, Population\n\n\n\n\nsource\n\n\n\n\n Population (individuals:Optional[List[__main__.Individual]]=None,\n             id:Optional[str]=None)\n\n*Represents a population of individuals.\nArgs: individuals (ListIndividual, optional): List of Individual objects in the population. Defaults to None. id (Optional[str]): Unique identifier for the population. Defaults to None.*\n\nsource\n\n\n\n\n Individual (genome:__main__.Genome, haplotypes:torch.Tensor,\n             id:Optional[str]=None, mother_id:Optional[str]=None,\n             father_id:Optional[str]=None,\n             breeding_values:Optional[torch.Tensor]=None,\n             phenotypes:Optional[torch.Tensor]=None)\n\n*Represents an individual in the breeding simulation.\nArgs: genome (Genome): Reference to the shared Genome object. haplotypes (torch.Tensor): Tensor representing the individual’s haplotypes. Shape: (ploidy, n_chromosomes, n_loci_per_chromosome). id (Optional[str]): Unique identifier. Defaults to None. mother_id (Optional[str]): Mother’s identifier. Defaults to None. father_id (Optional[str]): Father’s identifier. Defaults to None. breeding_values (Optional[torch.Tensor]): Breeding values for traits. Shape: (n_traits,). Defaults to None. phenotypes (Optional[torch.Tensor]): Phenotype for traits. Shape: (n_traits,). Defaults to None.*\n\nsource\n\n\n\n\n Genome (ploidy:int=2, n_chromosomes:int=10, n_loci_per_chromosome:int=5,\n         map_type:Optional[str]='random', chromosome_length:float=100.0)\n\n*Represents the genomic architecture for the simulation.\nArgs: ploidy (int): Ploidy level. Defaults to 2. n_chromosomes (int): Number of chromosomes. Defaults to 10. n_loci_per_chromosome (int): Number of loci per chromosome. Defaults to 5. map_type (str, optional): Type of genetic map (‘uniform’ or ‘random’). Defaults to ‘random’. chromosome_length (float): Genetic length of each chromosome in cM. Defaults to 100.0.*\n\n#example\n#core logic\nn_loci_per_chromosome = 100\nn_founders = 500\n\ngenome = Genome(n_loci_per_chromosome=n_loci_per_chromosome)\nfounder_pop = Population()\nfounder_pop.create_random_founder_population(genome, n_founders=n_founders)\n\nCreated genetic map\n\n\nTypeError: 'tuple' object is not callable\n\n\n\nsource\n\n\n\n\n create_population_dataloader (population:__main__.Population,\n                               batch_size:int, shuffle=True,\n                               num_workers=0, pin_memory=True)\n\nCreates a DataLoader for the given Population.\n\nsource\n\n\n\n\n PopulationDataset (population:__main__.Population, transform=None)\n\nPyTorch Dataset for loading genotypes from a Population.\n\ngenome = Genome()\npopulation = Population()\npopulation.create_random_founder_population(genome, n_founders=100)\n\n\ngenome.genetic_map\n\n\n# Create DataLoader\ndataloader = create_population_dataloader(population, batch_size=32)",
    "crumbs": [
      "Core"
    ]
  },
  {
    "objectID": "01_core.html#core",
    "href": "01_core.html#core",
    "title": "ChewC",
    "section": "",
    "text": "Contains the foundational Data Structures of the breeding program: Genome, Individual, Population\n\n\n\n\nsource\n\n\n\n\n Population (individuals:Optional[List[__main__.Individual]]=None,\n             id:Optional[str]=None)\n\n*Represents a population of individuals.\nArgs: individuals (ListIndividual, optional): List of Individual objects in the population. Defaults to None. id (Optional[str]): Unique identifier for the population. Defaults to None.*\n\nsource\n\n\n\n\n Individual (genome:__main__.Genome, haplotypes:torch.Tensor,\n             id:Optional[str]=None, mother_id:Optional[str]=None,\n             father_id:Optional[str]=None,\n             breeding_values:Optional[torch.Tensor]=None,\n             phenotypes:Optional[torch.Tensor]=None)\n\n*Represents an individual in the breeding simulation.\nArgs: genome (Genome): Reference to the shared Genome object. haplotypes (torch.Tensor): Tensor representing the individual’s haplotypes. Shape: (ploidy, n_chromosomes, n_loci_per_chromosome). id (Optional[str]): Unique identifier. Defaults to None. mother_id (Optional[str]): Mother’s identifier. Defaults to None. father_id (Optional[str]): Father’s identifier. Defaults to None. breeding_values (Optional[torch.Tensor]): Breeding values for traits. Shape: (n_traits,). Defaults to None. phenotypes (Optional[torch.Tensor]): Phenotype for traits. Shape: (n_traits,). Defaults to None.*\n\nsource\n\n\n\n\n Genome (ploidy:int=2, n_chromosomes:int=10, n_loci_per_chromosome:int=5,\n         map_type:Optional[str]='random', chromosome_length:float=100.0)\n\n*Represents the genomic architecture for the simulation.\nArgs: ploidy (int): Ploidy level. Defaults to 2. n_chromosomes (int): Number of chromosomes. Defaults to 10. n_loci_per_chromosome (int): Number of loci per chromosome. Defaults to 5. map_type (str, optional): Type of genetic map (‘uniform’ or ‘random’). Defaults to ‘random’. chromosome_length (float): Genetic length of each chromosome in cM. Defaults to 100.0.*\n\n#example\n#core logic\nn_loci_per_chromosome = 100\nn_founders = 500\n\ngenome = Genome(n_loci_per_chromosome=n_loci_per_chromosome)\nfounder_pop = Population()\nfounder_pop.create_random_founder_population(genome, n_founders=n_founders)\n\nCreated genetic map\n\n\nTypeError: 'tuple' object is not callable\n\n\n\nsource\n\n\n\n\n create_population_dataloader (population:__main__.Population,\n                               batch_size:int, shuffle=True,\n                               num_workers=0, pin_memory=True)\n\nCreates a DataLoader for the given Population.\n\nsource\n\n\n\n\n PopulationDataset (population:__main__.Population, transform=None)\n\nPyTorch Dataset for loading genotypes from a Population.\n\ngenome = Genome()\npopulation = Population()\npopulation.create_random_founder_population(genome, n_founders=100)\n\n\ngenome.genetic_map\n\n\n# Create DataLoader\ndataloader = create_population_dataloader(population, batch_size=32)",
    "crumbs": [
      "Core"
    ]
  },
  {
    "objectID": "02_trait.html",
    "href": "02_trait.html",
    "title": "ChewC",
    "section": "",
    "text": "contains logic for quantitative traits\n\n\nsource\n\n\n\n TraitModule (genome:chewc.core.Genome, founder_pop,\n              target_means:torch.Tensor, target_vars:torch.Tensor,\n              correlation_matrix:Optional[torch.Tensor],\n              n_qtl_per_chromosome:int)\n\nModule for managing and simulating multiple correlated additive traits.\n\nsource\n\n\n\n\n select_qtl_loci (num_qtl_per_chromosome:int, genome:chewc.core.Genome)\n\n*Randomly selects loci to be QTLs on each chromosome.\nArgs: num_qtl_per_chromosome (int): Number of QTLs to select per chromosome. genome (Genome): Genome object containing the chromosome structure.\nReturns: torch.Tensor: A boolean tensor indicating which loci are QTLs. Shape: (number_chromosomes, loci_per_chromosome)*\n\nploidy = 2\nn_chr = 10\nn_loci = 100\nn_Ind = 333\ng = Genome(ploidy, n_chr, n_loci)\npopulation = Population()\npopulation.create_random_founder_population(g, n_founders=n_Ind)\ninit_pop = population.get_dosages().float()  # gets allele dosage for calculating trait values\n\n# multi_traits\ntarget_means = torch.tensor([0, 5, 20])\ntarget_vars = torch.tensor([1, 1, 0.5])  # Note: I'm assuming you want a variance of 1 for the second trait\ncorrelation_matrix = [\n        [1.0, 0.2, 0.58],\n        [0.2, 1.0, -0.37],\n        [0.58, -0.37, 1.0],\n    ]\ncorrelation_matrix = torch.tensor(correlation_matrix)\n\nta = TraitModule(g, population, target_means, target_vars, correlation_matrix,100)\nta(population.get_dosages()).shape\n\nCreated genetic map\n\n\ntorch.Size([333, 3])\n\n\n\nploidy = 2\nn_chr = 10\nn_loci = 100\nn_Ind = 333\ng = Genome(ploidy, n_chr, n_loci)\npopulation = Population()\npopulation.create_random_founder_population(g, n_founders=n_Ind)\ninit_pop = population.get_dosages().float()  # gets allele dosage for calculating trait values\n\n# multi_traits\ntarget_means = torch.tensor([0, 5, 20])\ntarget_vars = torch.tensor([1, 1, 0.5])  # Note: I'm assuming you want a variance of 1 for the second trait\ncorrelation_matrix = [\n        [1.0, 0.2, 0.58],\n        [0.2, 1.0, -0.37],\n        [0.58, -0.37, 1.0],\n    ]\ncorrelation_matrix = torch.tensor(correlation_matrix)\n\nta = TraitModule(g, population, target_means, target_vars, correlation_matrix,100)\nta(population.get_dosages()).shape\n\nCreated genetic map\n\n\ntorch.Size([333, 3])\n\n\n\n# Define single trait parameters\ntarget_mean = torch.tensor(0.5)  # Single trait target mean\ntarget_var = torch.tensor(0.2)   # Single trait target variance\ncorrelation_matrix = None        # No correlation matrix for a single trait\nn_qtl_per_chromosome = 10 \n# Initialize the TraitModule for a single trait\ntrait_module = TraitModule(\n    genome=g,\n    founder_pop=population,\n    target_means=target_mean,\n    target_vars=target_var,\n    correlation_matrix=correlation_matrix,\n    n_qtl_per_chromosome=n_qtl_per_chromosome\n)",
    "crumbs": [
      "Trait"
    ]
  },
  {
    "objectID": "02_trait.html#trait",
    "href": "02_trait.html#trait",
    "title": "ChewC",
    "section": "",
    "text": "contains logic for quantitative traits\n\n\nsource\n\n\n\n TraitModule (genome:chewc.core.Genome, founder_pop,\n              target_means:torch.Tensor, target_vars:torch.Tensor,\n              correlation_matrix:Optional[torch.Tensor],\n              n_qtl_per_chromosome:int)\n\nModule for managing and simulating multiple correlated additive traits.\n\nsource\n\n\n\n\n select_qtl_loci (num_qtl_per_chromosome:int, genome:chewc.core.Genome)\n\n*Randomly selects loci to be QTLs on each chromosome.\nArgs: num_qtl_per_chromosome (int): Number of QTLs to select per chromosome. genome (Genome): Genome object containing the chromosome structure.\nReturns: torch.Tensor: A boolean tensor indicating which loci are QTLs. Shape: (number_chromosomes, loci_per_chromosome)*\n\nploidy = 2\nn_chr = 10\nn_loci = 100\nn_Ind = 333\ng = Genome(ploidy, n_chr, n_loci)\npopulation = Population()\npopulation.create_random_founder_population(g, n_founders=n_Ind)\ninit_pop = population.get_dosages().float()  # gets allele dosage for calculating trait values\n\n# multi_traits\ntarget_means = torch.tensor([0, 5, 20])\ntarget_vars = torch.tensor([1, 1, 0.5])  # Note: I'm assuming you want a variance of 1 for the second trait\ncorrelation_matrix = [\n        [1.0, 0.2, 0.58],\n        [0.2, 1.0, -0.37],\n        [0.58, -0.37, 1.0],\n    ]\ncorrelation_matrix = torch.tensor(correlation_matrix)\n\nta = TraitModule(g, population, target_means, target_vars, correlation_matrix,100)\nta(population.get_dosages()).shape\n\nCreated genetic map\n\n\ntorch.Size([333, 3])\n\n\n\nploidy = 2\nn_chr = 10\nn_loci = 100\nn_Ind = 333\ng = Genome(ploidy, n_chr, n_loci)\npopulation = Population()\npopulation.create_random_founder_population(g, n_founders=n_Ind)\ninit_pop = population.get_dosages().float()  # gets allele dosage for calculating trait values\n\n# multi_traits\ntarget_means = torch.tensor([0, 5, 20])\ntarget_vars = torch.tensor([1, 1, 0.5])  # Note: I'm assuming you want a variance of 1 for the second trait\ncorrelation_matrix = [\n        [1.0, 0.2, 0.58],\n        [0.2, 1.0, -0.37],\n        [0.58, -0.37, 1.0],\n    ]\ncorrelation_matrix = torch.tensor(correlation_matrix)\n\nta = TraitModule(g, population, target_means, target_vars, correlation_matrix,100)\nta(population.get_dosages()).shape\n\nCreated genetic map\n\n\ntorch.Size([333, 3])\n\n\n\n# Define single trait parameters\ntarget_mean = torch.tensor(0.5)  # Single trait target mean\ntarget_var = torch.tensor(0.2)   # Single trait target variance\ncorrelation_matrix = None        # No correlation matrix for a single trait\nn_qtl_per_chromosome = 10 \n# Initialize the TraitModule for a single trait\ntrait_module = TraitModule(\n    genome=g,\n    founder_pop=population,\n    target_means=target_mean,\n    target_vars=target_var,\n    correlation_matrix=correlation_matrix,\n    n_qtl_per_chromosome=n_qtl_per_chromosome\n)",
    "crumbs": [
      "Trait"
    ]
  },
  {
    "objectID": "04_cross.html",
    "href": "04_cross.html",
    "title": "ChewC",
    "section": "",
    "text": "Using gamete operations to produce new individuals\n\n/opt/hostedtoolcache/Python/3.10.14/x64/lib/python3.10/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nArgs: \n---- in \nGenerate random crosses from a set of parent haplotypes.\n...\n  else: warn(msg)\n/opt/hostedtoolcache/Python/3.10.14/x64/lib/python3.10/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n------- in \nGenerate random crosses from a set of parent haplotypes.\n...\n  else: warn(msg)\n\nsource\n\n\n\n random_crosses (genome:chewc.core.Genome,\n                 population:chewc.core.Population, n_crosses:int,\n                 reps:int)\n\n*Generate random crosses from a set of parent haplotypes.",
    "crumbs": [
      "Cross"
    ]
  },
  {
    "objectID": "04_cross.html#cross",
    "href": "04_cross.html#cross",
    "title": "ChewC",
    "section": "",
    "text": "Using gamete operations to produce new individuals\n\n/opt/hostedtoolcache/Python/3.10.14/x64/lib/python3.10/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nArgs: \n---- in \nGenerate random crosses from a set of parent haplotypes.\n...\n  else: warn(msg)\n/opt/hostedtoolcache/Python/3.10.14/x64/lib/python3.10/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n------- in \nGenerate random crosses from a set of parent haplotypes.\n...\n  else: warn(msg)\n\nsource\n\n\n\n random_crosses (genome:chewc.core.Genome,\n                 population:chewc.core.Population, n_crosses:int,\n                 reps:int)\n\n*Generate random crosses from a set of parent haplotypes.",
    "crumbs": [
      "Cross"
    ]
  },
  {
    "objectID": "04_cross.html#args",
    "href": "04_cross.html#args",
    "title": "ChewC",
    "section": "Args:",
    "text": "Args:\nparent_haplotypes (torch.Tensor): Haplotypes of the parents.\n                                   Shape: (n_parents, ploidy, chr, loci)\nn_crosses (int): Number of crosses to generate.\ngenome (Genome): Genome object.",
    "crumbs": [
      "Cross"
    ]
  },
  {
    "objectID": "04_cross.html#returns",
    "href": "04_cross.html#returns",
    "title": "ChewC",
    "section": "Returns:",
    "text": "Returns:\ntorch.Tensor: Haplotypes of the progeny.\n              Shape: (n_crosses, ploidy, chr, loci)*\n\nploidy = 2\nn_chr = 10\nn_loci = 1000\nn_Ind = 333\ng = Genome(ploidy, n_chr, n_loci)\npopulation = Population()\npopulation.create_random_founder_population(g, n_founders=n_Ind)\n\n# Convert to numpy array\n\nCreated genetic map\n\n\n\nrandom_crosses(g, population, 10, reps = 6).shape\n\ntorch.Size([10, 6, 2, 10, 1000])",
    "crumbs": [
      "Cross"
    ]
  },
  {
    "objectID": "05_agent.html",
    "href": "05_agent.html",
    "title": "ChewC",
    "section": "",
    "text": "ploidy = 2\nn_chr = 10\nn_loci = 1000\nn_Ind = 100\ng = Genome(ploidy, n_chr, n_loci)\npopulation = Population()\npopulation.create_random_founder_population(g, n_founders=n_Ind)\ninit_pop = population.get_dosages().float()  # gets allele dosage for calculating trait values\n\n# multi_traits\ntarget_means = torch.tensor([0, 5, 20])\ntarget_vars = torch.tensor([1, 1, 0.5])  # Note: I'm assuming you want a variance of 1 for the second trait\ncorrelation_matrix = [\n        [1.0, 0.2, 0.58],\n        [0.2, 1.0, -0.37],\n        [0.58, -0.37, 1.0],\n    ]\ncorrelation_matrix = torch.tensor(correlation_matrix)\ntraits = TraitModule(g, population, target_means, target_vars, correlation_matrix,100)\ntraits(population.get_dosages()).shape\n# example breeding step\n\nCreated genetic map\n\n\ntorch.Size([100, 3])\n\n\n\nclass BreedingExperiment:\n    def __init__(self, genotypes, trait_module, pop_size):\n        self.genotypes = genotypes\n        self.traits = traits\n        self.pop_size = pop_size\n    \n\ndef agent_action(environment):\n    \n    \n    genotypes = environment.genotypes\n    \n    #agent_network accepts this as input\n    \ndef do_cycle(agent_pick):\n    pass\n    \ndef take_action(action_value,environment):\n\n    #generate the next state given the action_value\n    \n    # the action will be a value between 0.1 and 0.9\n    phenotypes = environment.traits(environment.genotypes.sum(dim=1))[:,0]\n    #grab top k based on \n    select_pop = environment.genotypes[torch.topk(phenotypes, round(len(phenotypes) * action_value)).indices]\n    select_pop = Population([Individual(g, x) for x in select_pop])\n    random_crosses(g,select_pop,5, 1)\n    \n    \n    \n    \n    new_env = select_pop\n    return new_env\n\nrl_env = BreedingExperiment(population.get_genotypes(), traits, 100)\nact = take_action(.5, rl_env)\n\n\npopulation.get_genotypes().shape\n\ntorch.Size([100, 2, 10, 1000])",
    "crumbs": [
      "05_agent.html"
    ]
  },
  {
    "objectID": "net.html",
    "href": "net.html",
    "title": "ChewC",
    "section": "",
    "text": "import torch\n\n\n\n# Define the shape of the tensor\nb=100 #individuals\np=2 #ploidy\nc=5 #chromosome\nl = 10 #loci\ndef dummy_haplotypes(b,p,c,l): return torch.randint(0, 2, (b, p, c, l))\n\ndummy_mating_pool = dummy_haplotypes(b,p,c,l)\n#add batch dimension, single item per batch\n# dummy_mating_pool.unsqueeze(0) #(1, 100, 2, 5, 10)\nmating_pool_bv = torch.randn(b)\nmating_pool_bv = mating_pool_bv.unsqueeze(0) # (1,100)\n\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\nclass CNN1D(nn.Module):\n    def __init__(self):\n        super(CNN1D, self).__init__()\n        self.conv1 = nn.Conv1d(in_channels=2, out_channels=64, kernel_size=32, stride=8)\n        self.conv2 = nn.Conv1d(in_channels=64, out_channels=16, kernel_size=8, stride=2)\n        self.fc1 = nn.Linear(928, 64)\n        self.fc2 = nn.Linear(64, 32)  # Changed to 32 to match the dimension of combined features\n\n    def forward(self, x):\n        x1 = self.conv1(x)\n        x1 = nn.ReLU()(x1)\n        x1 = self.conv2(x1)\n        x1 = nn.ReLU()(x1)\n        x1 = x1.view(x1.size(0), -1)\n\n        x2 = self.conv1(x.flip(dims=[1]))\n        x2 = nn.ReLU()(x2)\n        x2 = self.conv2(x2)\n        x2 = nn.ReLU()(x2)\n        x2 = x2.view(x2.size(0), -1)\n\n        x = (x1 + x2) / 2\n        x = self.fc1(x)\n        x = nn.ReLU()(x)\n        x = self.fc2(x)\n        return x\n    \nclass MappingNetwork(nn.Module):\n    def __init__(self):\n        super(MappingNetwork, self).__init__()\n        self.mapping = nn.Linear(1, 16)\n\n    def forward(self, x):\n        x = self.mapping(x)\n        x = nn.ReLU()(x)\n        return x\n    \nclass CombinedModel(nn.Module):\n    def __init__(self):\n        super(CombinedModel, self).__init__()\n        self.geno_net = CNN1D()\n        self.meta_net = MappingNetwork()\n        self.fc1 = nn.Linear(32 + 16, 64)\n        self.fc2 = nn.Linear(64, 1)\n        self.sigmoid = nn.Sigmoid()  # Add sigmoid layer\n\n    def forward(self, geno_input, meta_input):\n        geno_features = self.geno_net(geno_input)\n        meta_features = self.meta_net(meta_input)\n        combined_features = torch.cat((geno_features, meta_features), dim=1)\n        x = self.fc1(combined_features)\n        x = nn.ReLU()(x)\n        x = self.fc2(x)\n        x = self.sigmoid(x)  # Apply sigmoid activation\n        return x\n\n# Example usage:\ninput_tensor = torch.randn(1, 2, 1000)  # [batch_size, channels, length]\nmeta_tensor = torch.tensor([[1.0]])  # [batch_size, 1]\n\nmodel = CombinedModel()\noutput = model(input_tensor, meta_tensor)\nprint(output)\n\ntensor([[0.4972]], grad_fn=&lt;SigmoidBackward0&gt;)",
    "crumbs": [
      "net.html"
    ]
  },
  {
    "objectID": "exp1.html",
    "href": "exp1.html",
    "title": "ChewC",
    "section": "",
    "text": "Truncation Selection Intensity * Budget\nThe RL agent will be given limited controls; it will only be able to select the top % of individuals used in random mating blocks\nHypothesis : we will see how the RL agent changes this % early versus later stages of the breeding program which will have an allotted time. e.g. 5 years vs 50 years vs 500 years and we will be able to see what dynamics it generally follows. Also we can give it a budget\nProcedure\n\n\nSet up breeding program(founder_pop, burn-in, traits…)\n\nInitial Rule-Based Selection: We begin with a fixed truncation selection, say selecting the top 20% of individuals based on their phenotype for the trait we want to improve. DRL Agent’s Action: The agent’s action is not to choose a new selection percentage outright, but rather to adjust the existing selection intensity. It would output a value that represents a change to the current 20%. For example: An action of +5 would increase the selection intensity to 25%. An action of -3 would decrease it to 17%. Bounded Action Space: We would define a range for these adjustments to keep the action space manageable and prevent extreme selections. For instance, the agent might only be able to adjust the selection intensity within ±10% of the initial value.\nuse an agent to decide which QTL to gene edit in a given line… plus budget etc… idea is that it will pick clever QTL based not on estimated additive value but also factor in haplotype diversity\nmay be interesting to see if it waits later in the breeding program to select/use budget for gene edits e.g. it waits til later stages of breeding program once the haplotype population structure plays out after generations of mendelian sampling.",
    "crumbs": [
      "Procedure"
    ]
  },
  {
    "objectID": "03_meiosis.html",
    "href": "03_meiosis.html",
    "title": "ChewC",
    "section": "",
    "text": "Simulating Meisois and Recombination for various Crossing actions\n\n~~ Note: might want to pull out the crossing over functions into a seperate module. They can be any function which returns a tensor of floats between 0 and max length of chromosome in cM\n\nsource\n\n\n\n poisson_crossing_over (chrom_lengths:torch.Tensor)\n\n*Generate crossing over locations for each chromosome given its length.\nArgs: chrom_lengths (torch.Tensor): A 1D tensor containing the lengths of the chromosomes in centiMorgans.\nReturns: list of tensors: A list of tensors, each containing the crossing over locations for a chromosome.*\n\nsource\n\n\n\n\n simulate_gametes (genome, parent_genomes, rate=1, shape=1, reps=1)\n\n*Simulate the formation of gametes for multiple parents using vectorized operations.\nArgs: genome (Genome): The Genome instance containing the genetic map and other parameters. parent_genomes (torch.Tensor): Genomes of the parents. Shape: (num_individuals, ploidy, num_chromosomes, num_loci) rate (float): Rate parameter for the crossover model. shape (float): Shape parameter for the crossover model. reps (int): Number of repetitions to generate novel gametes.\nReturns: torch.Tensor: The resultant gametes. Shape: (num_individuals, reps, ploidy//2, num_chromosomes, num_loci)*\n\nploidy = 2\nn_chr = 10\nn_loci = 1000\nn_Ind = 333\ng = Genome(ploidy, n_chr, n_loci)\npopulation = Population()\npopulation.create_random_founder_population(g, n_founders=n_Ind)\ninit_pop = population.get_genotypes().float()  # gets allele dosage for calculating trait values\n\nCreated genetic map\n\n\n\ngametes = simulate_gametes(g,population.get_genotypes(), population, reps = 66) ; gametes.shape\n\ntorch.Size([333, 66, 1, 10, 1000])",
    "crumbs": [
      "meiosis"
    ]
  },
  {
    "objectID": "03_meiosis.html#meiosis",
    "href": "03_meiosis.html#meiosis",
    "title": "ChewC",
    "section": "",
    "text": "Simulating Meisois and Recombination for various Crossing actions\n\n~~ Note: might want to pull out the crossing over functions into a seperate module. They can be any function which returns a tensor of floats between 0 and max length of chromosome in cM\n\nsource\n\n\n\n poisson_crossing_over (chrom_lengths:torch.Tensor)\n\n*Generate crossing over locations for each chromosome given its length.\nArgs: chrom_lengths (torch.Tensor): A 1D tensor containing the lengths of the chromosomes in centiMorgans.\nReturns: list of tensors: A list of tensors, each containing the crossing over locations for a chromosome.*\n\nsource\n\n\n\n\n simulate_gametes (genome, parent_genomes, rate=1, shape=1, reps=1)\n\n*Simulate the formation of gametes for multiple parents using vectorized operations.\nArgs: genome (Genome): The Genome instance containing the genetic map and other parameters. parent_genomes (torch.Tensor): Genomes of the parents. Shape: (num_individuals, ploidy, num_chromosomes, num_loci) rate (float): Rate parameter for the crossover model. shape (float): Shape parameter for the crossover model. reps (int): Number of repetitions to generate novel gametes.\nReturns: torch.Tensor: The resultant gametes. Shape: (num_individuals, reps, ploidy//2, num_chromosomes, num_loci)*\n\nploidy = 2\nn_chr = 10\nn_loci = 1000\nn_Ind = 333\ng = Genome(ploidy, n_chr, n_loci)\npopulation = Population()\npopulation.create_random_founder_population(g, n_founders=n_Ind)\ninit_pop = population.get_genotypes().float()  # gets allele dosage for calculating trait values\n\nCreated genetic map\n\n\n\ngametes = simulate_gametes(g,population.get_genotypes(), population, reps = 66) ; gametes.shape\n\ntorch.Size([333, 66, 1, 10, 1000])",
    "crumbs": [
      "meiosis"
    ]
  },
  {
    "objectID": "x01_chewc.html",
    "href": "x01_chewc.html",
    "title": "ChewC",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom fastcore.basics import patch\nimport uuid\n\nclass ChewC:\n    def __init___(self):\n        self.trait = None\n        self.genome = None\n        self.population = None\n\n        \nclass Genome:\n    def __init__(self, n_chr, n_loci):\n        self.ploidy = 2\n        self.n_chr = n_chr\n        self.n_loci = n_loci\n        self.shape = (self.ploidy, self.n_chr, self.n_loci)\n        \nclass Trait:\n    def __init__(self, genome, founder_population, target_mean, target_variance):\n        #store attributes\n        self.target_mean = target_mean\n        self.target_variance = target_variance\n        \n        #sample initial random effects\n        random_effects = np.random.randn(g.n_chr, g.n_loci)\n        #calculate the founder_population mean and var given these effects\n        founder_scores = np.array([random_effects @ x.haplotype for x in population.individuals])\n        founder_mean, founder_var = founder_scores.mean(), founder_scores.var()\n        #scale the random effects to match our target variance\n        scaling_factors = np.sqrt(self.target_variance / founder_var)\n        random_effects *= scaling_factors\n        self.effects = random_effects\n        \n        self.intercept = founder_mean - target_mean\n        \n    def __matmul__(self,other):\n        if isinstance(other,Individual):\n            return self.effects * other.haplotype + self.intercept\n        elif isinstance(other, Population):\n            return np.sum(np.array([self @ ind + self.intercept for ind in other.individuals]), axis=(1,2))\n\n        \nclass Population:\n    def __init__(self, genome, size=None):\n        self.genome = genome\n        self.ploidy = 2\n        if size:\n            self.size = size\n            self.individuals = self._create_initial_population()\n        else:\n            pass\n\n    def _create_initial_population(self):\n        \"\"\"Create an initial population of founder individuals.\"\"\"\n        return [Individual(self.genome) for _ in range(self.size)]\n    \n    def get_haplo(self):\n        return np.array([x.haplotype for x in self.individuals])\n    \n    def get_pheno(self):\n        return np.array([x.fitness for x in self.individuals])\n    \n    def __getitem__(self, index):\n        # Convert numpy arrays to lists for indexing\n        if isinstance(index, np.ndarray):\n            index = index.tolist()\n        # Handle list of indices\n        if isinstance(index, list):\n            return [self.individuals[i] for i in index]\n        # Handle single index\n        return self.individuals[index]\n    \n    def __repr__(self):\n        return f'Population of size: {self.size}'\n    \n\nclass Individual:\n    def __init__(self, genome,haplotype=None, mother = None, father = None, descendants = 0, source='founder', chewc=None):\n        self.genome = genome  # must be Genome class\n        self.haplotype = None\n        self.source = source  # 'founder', 'cross', 'self', 'dh'\n        self.descendents = []\n        self.fitness = 0\n        self.mother, self.father = mother, father\n\n        # Logic for setting haplotype,mother,father\n        if self.source == 'founder':\n            self.haplotype= self._generate_random_haplotype()\n        else:\n            self.haplotype = haplotype\n            \n        self.make_id()\n            \n    def __repr__(self):\n        return f'Individual with ID: {self.id[:3]}'\n    \n    def make_id(self):self.id = uuid.uuid4().hex\n\n\n    def _generate_random_haplotype(self):\n        \"\"\"Generate a random haplotype for the individual.\"\"\"\n        return np.random.choice([0, 1], size=(self.genome.ploidy, self.genome.n_chr, self.genome.n_loci))\n         \n\n# to do move this in another module\n@patch\ndef gamete(self:Individual):\n    haplotypes = self.haplotype\n    def shuffle_chr(chromosome_pair):\n        \"\"\"\n        Perform crossover on a pair of chromosomes.\n\n        Parameters:\n        chromosome_pair (list): A list of two equal length lists representing chromosomes.\n\n        Returns:\n        list: A new chromosome formed by shuffling the given chromosome pair.\n        \"\"\"\n        # Ensure the chromosome pair contains two chromosomes of equal length\n        assert len(chromosome_pair) == 2\n        assert len(chromosome_pair[0]) == len(chromosome_pair[1])\n\n        # Number of crossover points, sampled from a Poisson distribution with λ=1.3\n        n_crossover = np.random.poisson(1.3)\n\n        # Determine crossover locations, sampled without replacement from chromosome length\n        chromosome_length = len(chromosome_pair[0])\n        crossover_locs = np.sort(np.random.choice(chromosome_length, n_crossover, replace=False))\n\n        # Initialize the new chromosome and set the current chromosome to the first one\n        new_chromosome = []\n        current_chr = 0\n\n        # Perform crossover by alternating segments between the two chromosomes\n        last_loc = 0\n        for loc in crossover_locs:\n            new_chromosome.extend(chromosome_pair[current_chr][last_loc:loc])\n            current_chr = 1 - current_chr  # Switch to the other chromosome\n            last_loc = loc\n\n        # Append the remaining segment\n        new_chromosome.extend(chromosome_pair[current_chr][last_loc:])\n        return np.array(new_chromosome)\n\n    # Initialize an empty array to store the shuffled chromosomes\n    shuffled_haplotypes = np.zeros_like(haplotypes)\n    ploidy, n_chr, n_loci = chewc.genome.shape\n    # Iterate over each chromosome and apply the shuffle_chr function\n    for i in range(haplotypes.shape[1]):  # Iterate over the chromosomes\n        chromosome_pair = haplotypes[:, i, :]  # Extract the chromosome pair (2, 77)\n        shuffled_chromosome = shuffle_chr(chromosome_pair)  # Shuffle the chromosome pair    \n        shuffled_haplotypes[:, i, :] = np.array(shuffled_chromosome).reshape(1, n_loci)  # Store the shuffled chromosome\n    return shuffled_haplotypes[0,:,:]\n\nclass Trait:\n    def __init__(self, genome, founder_population, target_mean, target_variance):\n        #store attributes\n        self.target_mean = target_mean\n        self.target_variance = target_variance\n        \n        #sample initial random effects\n        initial_effects = np.random.randn(g.n_chr * g.n_loci)\n        initial_effects -= initial_effects.mean()\n        #calculate the founder_population mean and var given these effects\n        pop_scores = np.sum(founder_population.get_haplo(),axis=1).reshape(founder_population.size, g.n_chr*g.n_loci)\n        founder_scores = np.sum(initial_effects*pop_scores,axis=1)\n        founder_mean, founder_var = founder_scores.mean(), founder_scores.var()\n        scaling_factors = np.sqrt(self.target_variance / founder_var)\n        initial_effects *= scaling_factors\n        scaled_effects = initial_effects # ADDS A FIXED EFFECT SOMEHOW????\n        self.effects = scaled_effects\n        self.intercept = target_mean - founder_mean\n\n@patch\ndef x(self:Individual, partner):\n    if isinstance(partner,Individual):\n        source = 'cross'\n        progeny_haplo = np.vstack((self.gamete(), partner.gamete()))\n        \n        progeny = Individual(self.genome, progeny_haplo, self.id, partner.id,source=source, chewc = chewc)\n        return progeny\n    \n@patch\ndef __matmul__(self:Trait,other):\n    if isinstance(other,Individual):\n#             print(f' intercept {self.intercept}')\n        breeding_value = self.effects * np.sum(other.haplotype,axis=0).flatten()\n        return breeding_value\n    else:\n        print('ffff')\n@patch\ndef phenotype(self:Individual, h2, environmental_variance):\n    \"\"\"\n    Calculate the phenotype for the individual.\n\n    Args:\n        h2 (float): Heritability of the trait.\n        environmental_variance (float): The calculated environmental variance for the population.\n    \"\"\"\n    breeding_value = chewc.trait @ self\n    phenotype_value = breeding_value + np.random.normal(0, np.sqrt(environmental_variance))\n    self.fitness = np.sum(phenotype_value)\n    \n@patch\ndef trial(self:Population, h2):\n    \"\"\"\n    Simulate phenotypes for all individuals in the population.\n\n    Args:\n        h2 (float): Heritability of the trait.\n    \"\"\"\n    # 1. Calculate environmental variance at the population level\n    population_genetic_variance = np.var(chewc.population.get_pheno(), ddof=1)\n    environmental_variance = (1 - h2) / h2 * population_genetic_variance\n\n    # 2. Phenotype each individual, passing the environmental variance\n    for individual in self.individuals:\n        individual.phenotype(h2, environmental_variance) \n\n\n@patch\ndef truncation(self:Population, top_percent):\n    \"\"\"\n    Returns the indexes of phenotypes in the top percent.\n\n    Args:\n        top_percent (float): The top percentage of individuals to select (0 &lt; top_percent &lt;= 100).\n    \"\"\"\n    # Ensure the top_percent is within the valid range\n    if top_percent &lt;= 0 or top_percent &gt; 100:\n        raise ValueError(\"top_percent must be between 0 and 100\")\n\n    # Calculate the number of individuals to select\n    num_to_select = int(population.size * top_percent / 100)\n\n    # Get the phenotypes of all individuals\n    phenotypes = self.get_pheno()\n    assert phenotypes.sum() != 0, 'no phenotypes present'\n#     print(phenotypes)\n\n    # Get the indices that would sort the array in descending order\n    sorted_indices = np.argsort(phenotypes)[::-1]\n\n    # Select the top individuals based on the sorted indices\n    top_indices = sorted_indices[:num_to_select]\n\n    return self[top_indices]\n\ndef randomize_pairing(input_array):\n    # Convert input array to numpy array if it isn't already\n    array = np.array(input_array)\n    \n    # Shuffle the array\n    np.random.shuffle(array)\n    \n    # Pair the elements\n    n = len(array)\n    if n % 2 != 0:\n        # If the length of the array is odd, remove a random element\n        remove_idx = np.random.choice(n)\n        array = np.delete(array, remove_idx)\n        n -= 1\n    \n    pairs = [(array[i], array[i + 1]) for i in range(0, n, 2)]\n    \n    return pairs\n\n\n#Define the Simulation Parameters\ng = Genome(3, 1000)\npopulation = Population(g, size=999)\ntrait = Trait(g, population,5,1000)\n\n#Plug them into ChewC\nchewc = ChewC()\nchewc.trait = trait\nchewc.population = population\nchewc.genome = g",
    "crumbs": [
      "x01_chewc.html"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ChewC",
    "section": "",
    "text": "In short, this will be a GPU-enabled stochastic simulation for breeding programs with an emphasis on cost-benefit-analysis for novel breeding tools and creating a suitable interface for RL agents.\nWe will also incorporate an emphasis on budget and costs associated with each action to manage long-term breeding budgets. As well as model theoretical tools in the plant breeder’s toolbox. e.g.\nEach treatment will cost $$ ultimately helping guide the implementation in real-world breeding programs.",
    "crumbs": [
      "ChewC"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "ChewC",
    "section": "Install",
    "text": "Install\npip install chewc\n\n\n\nPhenotype Animation For Basic Truncation Selection",
    "crumbs": [
      "ChewC"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "ChewC",
    "section": "How to use",
    "text": "How to use\nFirst, define the genome of your crop\n\nploidy = 2\nn_chr = 10\nn_loci = 1000\nn_Ind = 100\ng = Genome(ploidy, n_chr, n_loci)\npopulation = Population()\npopulation.create_random_founder_population(g, n_founders=n_Ind)\ninit_pop = population.get_dosages().float()  # gets allele dosage for calculating trait values\n\n# multi_traits\ntarget_means = torch.tensor([0, 5, 20])\ntarget_vars = torch.tensor([1, 1, 0.5])  # Note: I'm assuming you want a variance of 1 for the second trait\ncorrelation_matrix = [\n        [1.0, 0.2, 0.58],\n        [0.2, 1.0, -0.37],\n        [0.58, -0.37, 1.0],\n    ]\ncorrelation_matrix = torch.tensor(correlation_matrix)\n\nCreated genetic map\n\n\n\nrandom_crosses(g, population, n_crosses= 10, reps = 1).shape\n\ntorch.Size([10, 1, 2, 10, 1000])",
    "crumbs": [
      "ChewC"
    ]
  }
]